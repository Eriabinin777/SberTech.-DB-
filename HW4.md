# LiteDB

![Текст с описанием картинки](/images/HW4-1.png)

## Введение 

База данных NoSQL (первоначально обозначаемая как "не SQL" или "нереляционная") предоставляет механизм для хранения и извлечения данных, которые моделируются средствами, отличными от табличных отношений, используемых в реляционных базах данных. Базы данных NoSQL все чаще используются в больших данных и веб-приложениях реального времени.

Ничто не может быть более показательным для внезапного перехода на NoSQL, чем устоявшиеся компании, такие как Facebook, Google и Amazon.com на основе хорошо зарекомендовавших себя технологий реляционных баз данных. Кажется, что в один прекрасный день Веб управлялся несколькими СУБД, а на следующий день пять или около того решений NoSQL зарекомендовали себя как достойные решения.

Сказав все это, первое, что мы должны сделать, это объяснить, что подразумевается под NoSQL. В то время как поставщики реляционных баз данных исторически пытались позиционировать свое программное обеспечение как универсальное решение, NoSQL ориентируется на меньшие подразделения ответственности, где лучший инструмент для данной работы часто является гибким. NoSQL - это открытость и осведомленность об альтернативных, существующих и дополнительных шаблонах и инструментах для управления вашими данными.

Для более подробного ознакомления с базами данных NoSQL, пожалуйста, перейдите по этой [ссылке](https://russianblogs.com/article/30071264964/).

LiteDB - это простое, быстрое и бесплатное встроенное хранилище документов .NET NoSQL в одном файле данных. Вдохновленный MongoDB, поддерживает коллекции, классы POCO, документы Bson, индексы, потоковые данные, транзакции ACID и выражения LINQ. [Официальный сайт LiteDB](https://www.litedb.org/).

Для начала вам необходимо понять пять простых концепций.

1. LiteDB использует ту же концепцию базы данных, с которой многие уже знакомы. В экземпляре LiteDB может быть ноль или более баз данных (версий), каждая из которых действует как высокоуровневые контейнеры для всего остального.
2. База данных может содержать ноль или более коллекций. Коллекция имеет достаточно общего с традиционной таблицей, так что вы можете смело считать их одним и тем же.
3. Коллекции состоят из нуля или более документов. Опять же, документ можно безопасно рассматривать как строку.
4. Документ состоит из одного или нескольких полей, которые, как вы, вероятно, догадываетесь, во многом похожи на столбцы или свойства класса.
5. Индексы в LiteDB функционируют в основном так же, как и их аналоги в СУБД.

## Характеристики

* Бессерверное хранилище документов NoSQL
* Простой API, очень похожий на официальный драйвер MongoDB
* 100% C #-код для .NET 3.5 /4.0 в одной DLL (менее 300 КБ) - Без зависимостей
* Поддержка переносимых платформ: Полная.NET и NET Standard 1.3+2.0 (для UWP 10, Xamarin iOS и Android)
* Потокобезопасный / многопроцессорный
* Восстановление при сбое записи (режим журнала)
* Поддержка классов POCO или BsonDocument
* Шифрование файла данных с использованием криптографии DES
* Хранилище файлов и потоковых данных (например, GridFS в MongoDB)
* Хранилище с одним файлом данных (например, SQLite)
* Индексированные поля документа для быстрого поиска (до 16 индексов в коллекции)
* Поддержка LINQ для запросов с поддержкой Include
* Командная строка командной оболочки (попробуйте эту онлайн-версию)
* С открытым исходным кодом и бесплатно для всех, включая коммерческое использование
* Установка из NuGet: Установочный пакет LiteDB
 
LiteDB во многом вдохновлен MongoDB. Я попытался создать базу данных, которая работает как MongoDB, но в очень малом масштабе, используя только самые важные функции для небольших приложений. Если вы знаете MongoDB, вы уже знаете LiteDB.

У LiteDB имеется официальный [GitHub](https://github.com/mbdavid/LiteDB), на котором лежат все исходники

## Где использовать?

* Небольшие веб-приложения, сайты, блоги или форумы
* Один файл данных для каждой учетной записи / хранилища данных пользователя
* Настольные / локальные небольшие приложения
* Формат файла приложения
* Несколько операций записи пользователей с параллелизмом

## История развития

Полная летопись развития LiteDB находится [здесь](https://github.com/mbdavid/LiteDB/releases?page=1). LiteDB была создана 25 января 2015 году. В настоящее время выпущена 5 версия данной СУБД. Ниже приведен небольшой список наиболее важных обновлений с изменениями.

Обновленная версия v5.0.16 - 19 марта 2023
* Использовать только мьютекс для общего механизма открытия и закрытия синхронизации и удалить блокировки с помощью@dev-joshiв № 2293
* Исправлена обработка Min(Func<T,TResult>) с помощью@gcrossland-cosworthв № 2287
* Измените тип возвращаемого значения ILiteRepository.Insert, чтобы он соответствовал ILiteDatabase.Insert,@InvisiblePhilв # 2260
* Исправлена опечатка@iArmanKarimiв № 2267
* Исправлена SqlLike@pjy612в № 2235

Обновление версии v5.0.0-alpha - 5 августа 2019
* Полностью новый движок - WAL (Write Ahead Log)
* Управление многоверсионным параллелизмом (снимки и контрольные точки)
* Полное сопровождение сделки
* Поддержка нескольких ридеров без блокировки
* Написать блокировку на уровне коллекции, а не на уровне базы данных
* Удвоено количество индексов на коллекцию, теперь до 32 индексов на коллекцию.
* Новый FileStorageс пользовательским Idтипом
* Новое BsonExpressions: преобразование, фильтрация, сопоставление, уменьшение, ..
* Новый Query Pipe внутри движка
* Простое обновление существующих баз данных LiteDB v4 (используйте upgrade=trueв строке подключения)
* Новый посетитель Linq (с поддержкой дополнительных выражений)
* Новый беглыйQuery
* И не один год напряженной работы!!
* Поддержка нового языка SQL — очень похоже на ANSI SQL.
* Выбрать, Вставить, Обновить, Удалить, Создать индекс, Удалить индекс, Удалить коллекцию, Объяснить
* Поддержка GroupBy, Наличие, Лимит, Смещение, OrderBy, Включает, ...
* Системные коллекции (получить информацию о базе данных)
* Поддержка системных функций (импорт/экспорт CSV/JSON)
* Новый графический интерфейс для Windows
* Несколько вкладок, несколько потоков, несколько транзакций
* Взаимодействуйте с вашей базой данных и коллекциями с помощью операторов SQL.

Обновление версии 4.0.0 - 18 октября 2017
* Только для NET4
* Новая поддержка выражений
* Исправлены проблемы параллелизма в версии v3
* Поддержка переносимости с использованием NETStandard 1.3 + 2.0
* Обновление v2.0.0 - 1 назад 2016
* Поддержка Portable - UWP, Xamarin - iOS и Android
* .NET 3.5
* Новый доступ к диску, позволяющий избежать функций блокировки: используйте только эксклюзивный режим чтения / записи
* Вернули некоторые функции версии v1: управление пользовательскими транзакциями, регистрацию AutoID и экземпляр global mapper

Обновление v.2.0.0-rc - 24 декабря 2015
* Файл данных шифрования
* Перенос файла данных с версии 0.9.0 / v1.0.x
* Дамп файла данных как вставка
* Улучшенная поддержка кэша / параллелизма
* Счастливого Рождества :)

Обновление v.2.0.0-бета - 27 ноября 2015
* Абстрактный уровень сохранения
* Fluent mapper API
* новый DBRef
* Поле виртуального индекса
* Новая система очистки кэша
* Поддержка начального размера базы данных и максимального размера базы данных
* Отложенная загрузка.
* Защита от потоков и процессов
* Сжатие файлов данных
* Информация журнала базы данных

Обновление v1.0.2 - 17 мая 2015
* Лучше, чтобы BsonMapper сериализовал / десериализовал интерфейсы и базовые классы, используя поле _type в документе (как используется в MongoDB)
* BsonMapper для сбора значений имен
* Добавлена поддержка логических операций Linq, таких как x => x.isActive
* Исправлена ошибка в операциях обновления / удаления индекса строки
* Удалены операции поиска документов при полном сканировании - теперь работает только с индексом
* Автоматическое создание индекса, если он не существует

Обновление v1.0 - 28 марта 2015
* Новый BsonSerializer удаляет fastBinaryJson и реализует реальную спецификацию BSON
* Новый BsonMapper для получения более настраиваемого POCO из / в BsonDocument
* Новая реализация JsonReader: без регулярных выражений и в 4 раза быстрее
* Новый идентификатор объекта, который будет использоваться в документах Id
* Параметры создания индекса - удаление пробелов, удаление акцентов, игнорирование регистра
* Атрибут [BsonIndex] для обозначения вашего свойства объекта для автоматического создания индекса при запросе
* Идентификатор автоматической генерации для свойства entity Id
* Find() может быть выполнен без индекса (выполнит полное сканирование документа)
* FindAll() поддерживает результаты по возрастанию / убыванию
* Минимальное () / Максимальное() значение из индекса
* DBRef<> - простой класс для справочного документа
* Улучшен сбор данных и индекс удаления
* Удалена коллекция _master - не прочитана 1 страница

Обновление версии 0.9 - 07 февраля 2015
* Добавили банковскую метку MongoDB
* Добавилен краткий обзор оболочки

Начальная версия - 25 января 2015

## Инструменты для взаимодействия и языки программирования

LiteDB — это бессерверная база данных, поставляемая в виде одной небольшой библиотеки DLL (< 450 КБ), полностью написанной на управляемом коде .NET C# (совместимом с .NET 4.5 и NETStandard 2.0).

* LiteDB поддерживает SQL-подобный язык для обработки данных и структур. Вы можете вставлять, обновлять, удалять или запрашивать базу данных, используя очень похожий реляционный язык SQL.
* Выражения LINQ (лямбда-функции) можно использовать для создания плавного запроса API в коде C#.
* Все команды SQL поддерживаются в новом инструменте администрирования LiteDB.Studio .
* Вы также можете получить подробный EXPLAIN PLAN от механизма запросов, чтобы проверить, будет ли ваш запрос выполняться с максимальной производительностью.
* LiteDB полностью написан на управляемом коде C#.
* Поддержка .NET Framework 4.5 и .NET Standard 1.3 и 2.0, .NET Core 2.0+, UWP, Linux, мобильного Xamarin (iOS и Android), Unity... на каждой платформе .NET
* LiteDB является бесплатным и открытым исходным кодом?

Информация взята с официального сайта.

![Текст с описанием картинки](/images/HW4-2.png)

## Database engine

Еще одно преимущество использования LiteDB заключается в том, что существует также «LiteDB Studio» , которую вы можете установить (фактически собрать из исходников) отдельно. Он позволяет подключаться к локальной базе данных и управлять ею с помощью приятного пользовательского интерфейса. Исходники можно посмотреть [здесь](https://github.com/mbdavid/LiteDB.Studio).

![Текст с описанием картинки](/images/HW4-3.jpg)

## Установка и начало работы

Скачать LiteDB можно по [ссылке](https://www.nuget.org/packages/LiteDB/). Более подробную информацию о установке можно найти [здесь](https://www.litedb.org/docs/getting-started/) и [здесь](https://litedb.readthedocs.io/en/latest/getting-started/getting-started.html). Полезное будет вот это [видео](https://www.youtube.com/watch?v=d2N4Ia8Wwd0), в котором показано, как работать с этой СУБД, а также есть [видео](https://www.youtube.com/watch?v=a3m4B5m6IqQ), где показано, как добавить LiteDB в Visual Studio.

## Примеры запросов и индексация

### ***Наследование***

Специфика моей программы такова. Я хочу сохранять в базу простые объекты типа:

```
internal class Item
{
  public string Title { get; set; }

 public string Description { get; set; }

 public List<Field> Fields { get; set; } = new List<Field>();
}
```
Но вот класс `Field` у меня абстрактный, имеющий массу наследников:

```
internal abstract class Field
{
}

internal sealed class TextField : Field
{
 public string Text { get; set; }
}

internal sealed class PasswordField : Field
{
 public string Password { get; set; }
}

internal sealed class DescriptionField : Field
{
 public string Description { get; set; }
}
```

При работе с SQL базами данных мне приходилось настраивать сохранение различных наследников класса `Field`. Я полагал, что в LiteDB мне придётся писать собственный механизм BSON-сериализации, благо такая возможность предоставляется. Но LiteDB меня приятно удивил. Никаких усилий с моей стороны не потребовалось. Сохранение и восстановление различных типов происходит совершенно без моего участия. Вы создаёте нужные объекты:

```
var items = new Item[]
{
 new Item
 {
 Title = "item1",
 Description = "description1",
 Fields =
 {
 new TextField
 {
 Text = "text1"
 },
 new PasswordField
 {
 Password = "123"
 }
 }
 },
 new Item
 {
 Title = "item2",
 Description = "description2",
 Fields =
 {
 new TextField
 {
 Text = "text2"
 },
 new DescriptionField
 {
 Description = "description2"
 }
 }
 }
};
```
и вставляете их в базу данных:

```
using (var db = new LiteDatabase(connectionString))
{
 var collection = db.GetCollection<Item>();

 collection.InsertBulk(items);
}
```
Вот и всё. LiteDB поставляется с удобной программой LiteDB.Studio, которая позволяет вам исследовать содержимое вашей базы данных. Давайте посмотрим, как хранятся наши объекты:

```
{
 "_id": {"$oid": "62bf12ce12a00b0f966e9afa"},
 "Title": "item1",
 "Description": "description1",
 "Fields":
 [
 {
 "_type": "LiteDBSearching.TextField, LiteDBSearching",
 "Text": "text1"
 },
 {
 "_type": "LiteDBSearching.PasswordField, LiteDBSearching",
 "Password": "123"
 }
 ]
}
```
Оказывается, что для каждого объекта в поле `_type` сохраняется его тип, что и позволяет правильно восстановить объект при чтении из базы.

Что ж, с сохранением разобрались. Давайте перейдём к чтению.

### ***Поиск текста***

Как я уже сказал, мне необходимо искать объекты Item в свойствах `Title` и `Description` которых, а так же в свойствах их полей (свойство `Fields`) содержится определённый текст.

С поиском внутри свойств `Title` и `Description` всё ясно. Документация содержит понятные примеры:

```
var items = collection.Query()
 .Where(i => i.Title.Contains("1") || i.Description.Contains("1"))
 .ToArray();
 ```
 
Но с поиском в полях есть проблема. Дело в том, что абстрактный класс Field не определяет никаких свойств. Поэтому я не могу на них сослаться здесь. К счастью LiteDB позволяет использовать строковую запись запросов:

```
var items = collection.Query()
 .Where("$.Title LIKE '%1%' OR $.Description LIKE '%1%'")
 .ToArray();
 ```
 Но как с её помощью искать внутри полей? Документация даёт подсказку, что выражение должно выглядеть примерно так:
 
 ```
 $.Title LIKE '%1%' OR $.Description LIKE '%1%' OR ANY($.Fields[@.Text LIKE '%1%']) 
OR ANY($.Fields[@.Description LIKE '%1%']) OR ANY($.Fields[@.Password LIKE '%1%'])
```

Здесь меня смущали две вещи. Во-первых, для каждого нового типа поля мне могло потребоваться дописывать это выражение, если оно использовало новое имя текстового свойства, в котором мне нужно было осуществлять поиск. Можно ли что-то сделать по этому поводу? Можно.

LiteDB поддерживает атрибут `BsonField`, который позволяет задавать имя поля базы данных, в котором будет храниться данное свойство. Можно использовать его так:

```
internal sealed class TextField : Field
{
 [BsonField("TextField")]
 public string Text { get; set; }
}

internal sealed class PasswordField : Field
{
 [BsonField("TextField")]
 public string Password { get; set; }
}

internal sealed class DescriptionField : Field
{
 [BsonField("TextField")]
 public string Description { get; set; }
}
```

Теперь можно использовать одно поисковое выражение для любых объектов `Field`:

```
$.Title LIKE '%1%' OR $.Description LIKE '%1%' OR $.Fields[*].TextField ANY LIKE '%1%'
```

Добавляя нового наследника класса Field, я могу просто пометить его свойство атрибутом 'BsonField("TextField")'. Тогда мне не придётся вносить никаких изменений в поисковое выражение.

К сожалению этот способ не совсем решает все наши проблемы. Дело в том, что у наследника 'Field' может быть произвольное число свойств, в которых нужно осуществлять поиск. Поэтому может оказаться, что их нельзя привести к уже имеющимся в базе полям.

У неё есть ещё одна проблема. Мне несколько раз пришлось писать искомую строку `'%1%'`. Да и SQL Injection ещё никто не отменял (хотя не уверен, применимо ли здесь использовать слово SQL). Короче говоря, я веду к тому, что неплохо было бы использовать параметры запроса. И действительно, API позволяет это делать:

Но как конкретно мне сослаться на параметр в тексте запроса? К сожалению, документация опять подвела меня. Пришлось лезть в код тестов для LiteDB и искать там, как следует использовать параметры:

```
var items = collection.Query()
 .Where("$.Title LIKE @0 OR $.Description LIKE @0 OR ($.Fields[*].Text ANY LIKE @0) 
OR ($.Fields[*].Description ANY LIKE @0) OR ($.Fields[*].Password ANY LIKE @0)", "%1%")
 .ToArray();
 ```
 
 ### ***Индексация***
 
LiteDB повышает производительность поиска, используя индексы для полей или выражений документа. В каждом индексе хранится значение определенного выражения, упорядоченное по значению (и типу). Без индекса LiteDB должен выполнить запрос, используя полное сканирование документа. Полное сканирование документов неэффективно, поскольку LiteDB должна десериализовать каждый документ в коллекции.

Индексы в LiteDB реализованы с помощью списков пропуска . Списки пропуска представляют собой отсортированные с двойной связью списки, содержащие до 32 уровней. Списки пропуска очень просты в реализации (всего 15 строк кода) и статистически сбалансированы.

Операции вставки и поиска имеют среднюю сложность O (log n). Это означает, что в коллекции с 1 миллионом документов операция поиска по индексированному выражению займет около 13 шагов, чтобы найти нужный документ. Если вы хотите узнать больше о списках пропуска, посмотрите это [замечательное видео](https://www.youtube.com/watch?v=kBwUoWpeH_Q). 

Более подробную информацию про индексы можно найти в [документации](https://www.litedb.org/docs/indexes/).

Конечно, моё приложение будет хранить не такой большой объём данных, чтобы это было критически важно. Но всё же было бы хорошо, чтобы мои запросы использовали индексы и выполнялись быстро.

Во-первых, как нам узнать, использует ли данный запрос индекс или нет. Для этого в LiteDB есть команда `EXPLAIN`. В LiteDB.Studio я выполню свой запрос так:

```
EXPLAIN
SELECT $ FROM Item
WHERE $.Title LIKE '%1%'
    OR $.Description LIKE '%1%'
    OR ($.Fields[*].Text ANY LIKE '%1%')
 OR ($.Fields[*].Description ANY LIKE '%1%')
  OR ($.Fields[*].Password ANY LIKE '%1%')
```

Результат выполнения этой команды содержит следующую информацию об используемом индексе:
```
"index":
 {
 "name": "_id",
 "expr": "$._id",
 "order": 1,
 "mode": "FULL INDEX SCAN(_id)",
 "cost": 100
 },
 ```
 Как видите, сейчас применяется полный просмотр всех данных. Хотелось бы добиться лучшего результата.

Документация прямо говорит, что возможно создать индекс на основе свойств типа массив. При этом можно будет осуществлять поиск любого входящего в такие массивы значения. Например, вот так можно создать индекс для поиска информации в свойствах `Text` моих поле

```
collection.EnsureIndex("TextIndex", "$.Fields[*].Text");
```

Теперь этот индекс можно использовать в поиске:

```
var items = collection.Query()
 .Where("$.Fields[*].Text ANY LIKE @0", "%1%")
 .ToArray();
```

Команда `EXPLAIN` в LiteDB.Studio показывает, что этот запрос действительно использует созданный нами индекс:

```
"index":
 {
 "name": "TextIndex",
 "expr": "MAP($.Fields[*]=>@.Text)",
 "order": 1,
 "mode": "FULL INDEX SCAN(TextIndex LIKE \"%1%\")",
 "cost": 100
 },
 ```
 
Но как нам объединить в один индекс все наши свойства? На помощь приходит команда CONCAT. Она объединяет в один массив несколько свойств. Вот как будет выглядеть создание полного индекса:

```
collection.EnsureIndex("ItemsIndex", @"CONCAT($.Title,
 CONCAT($.Description,
 CONCAT($.Fields[*].Text,
 CONCAT($.Fields[*].Password,
 $.Fields[*].Description
 )
 )
 )
 )");
```
Чтобы искать по нему, нам придётся переписать наше поисковое выражение:

```
var items = collection.Query()
    .Where(
        @"CONCAT($.Title,
            CONCAT($.Description,
                CONCAT($.Fields[*].Text,
                    CONCAT($.Fields[*].Password,
                            $.Fields[*].Description
                    )
                )
            )
        ) ANY LIKE @0",
        "%1%")
    .ToArray();
```
Теперь наш поиск действительно использует индекс:

```
"index":
  {
    "name": "ItemsIndex",
    "expr": "CONCAT($.Title,CONCAT($.Description,CONCAT(MAP($.Fields[*]=>@.Text),CONCAT(MAP($.Fields[*]=>@.Password),MAP($.Fields[*]=>@.Description)))))",
    "order": 1,
    "mode": "FULL INDEX SCAN(ItemsIndex LIKE \"%3%\")",
    "cost": 100
  },
 ```
 
К сожалению, оператор `LIKE` всё равно приводит к `FULL INDEX SCAN`. Остаётся надеяться, что индекс всё же даёт некоторый выигрыш. Хотя, зачем нам надеяться. Мы же можем всё измерить. У нас же есть BenchmarkDotNet.

Я написал вот такой класс для проведения тестов быстродействия:

```
[SimpleJob(RuntimeMoniker.Net60)]
public class LiteDBSearchComparison
{
    private LiteDatabase _database;
    private ILiteCollection<Item> _collection;

    [GlobalSetup]
    public void Setup()
    {
        if (File.Exists("compare.dat"))
            File.Delete("compare.dat");

        _database = new LiteDatabase("Filename=compare.dat");

        _collection = _database.GetCollection<Item>();

        _collection.EnsureIndex("ItemIndex", @"CONCAT($.Title,
            CONCAT($.Description,
                CONCAT($.Fields[*].Text,
                    CONCAT($.Fields[*].Password,
                            $.Fields[*].Description
                    )
                )
            )
        )");

        for (int i = 0; i < 100; i++)
        {
            var item = new Item
            {
                Title = "t",
                Description = "d",
                Fields =
                {
                    new TextField { Text = "te" },
                    new PasswordField { Password = "p" },
                    new DescriptionField { Description = "de" }
                }
            };

            _collection.Insert(item);
        }
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        _database.Dispose();
    }

    [Benchmark(Baseline = true)]
    public void WithoutIndex()
    {
        _ = _collection.Query()
            .Where("$.Title LIKE @0 OR $.Description LIKE @0 OR ($.Fields[*].Text ANY LIKE @0) OR ($.Fields[*].Description ANY LIKE @0) OR ($.Fields[*].Password ANY LIKE @0)",
                "%1%")
            .ToArray();
    }

    [Benchmark]
    public void WithIndex()
    {
        _ = _collection.Query()
            .Where(@"CONCAT($.Title,
                        CONCAT($.Description,
                            CONCAT($.Fields[*].Text,
                                CONCAT($.Fields[*].Password,
                                        $.Fields[*].Description
                                )
                            )
                        )
                    ) ANY LIKE @0",
                "%1%")
            .ToArray();
    }
}
```
Результаты, которые я получил для него, следующие:

|Method|Mean|Error|StdDev|Ratio|
|:-:|:-:|:-:|:-:|:-:|
|C индексом|752.7 us|14.71 us|21.56 us|1.00|
|Без индекса|277.5 us|4.30 us|4.02 us|0.37|

