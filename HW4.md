# LiteDB

![Текст с описанием картинки](/images/HW4-1.png)

## Введение 

База данных NoSQL (первоначально обозначаемая как "не SQL" или "нереляционная") предоставляет механизм для хранения и извлечения данных, которые моделируются средствами, отличными от табличных отношений, используемых в реляционных базах данных. Базы данных NoSQL все чаще используются в больших данных и веб-приложениях реального времени.

Ничто не может быть более показательным для внезапного перехода на NoSQL, чем устоявшиеся компании, такие как Facebook, Google и Amazon.com на основе хорошо зарекомендовавших себя технологий реляционных баз данных. Кажется, что в один прекрасный день Веб управлялся несколькими СУБД, а на следующий день пять или около того решений NoSQL зарекомендовали себя как достойные решения.

Сказав все это, первое, что мы должны сделать, это объяснить, что подразумевается под NoSQL. В то время как поставщики реляционных баз данных исторически пытались позиционировать свое программное обеспечение как универсальное решение, NoSQL ориентируется на меньшие подразделения ответственности, где лучший инструмент для данной работы часто является гибким. NoSQL - это открытость и осведомленность об альтернативных, существующих и дополнительных шаблонах и инструментах для управления вашими данными.

Для более подробного ознакомления с базами данных NoSQL, пожалуйста, перейдите по этой [ссылке](https://russianblogs.com/article/30071264964/).

LiteDB - это простое, быстрое и бесплатное встроенное хранилище документов .NET NoSQL в одном файле данных. Вдохновленный MongoDB, поддерживает коллекции, классы POCO, документы Bson, индексы, потоковые данные, транзакции ACID и выражения LINQ. [Официальный сайт LiteDB](https://www.litedb.org/).

Для начала вам необходимо понять пять простых концепций.

1. LiteDB использует ту же концепцию базы данных, с которой многие уже знакомы. В экземпляре LiteDB может быть ноль или более баз данных (версий), каждая из которых действует как высокоуровневые контейнеры для всего остального.
2. База данных может содержать ноль или более коллекций. Коллекция имеет достаточно общего с традиционной таблицей, так что вы можете смело считать их одним и тем же.
3. Коллекции состоят из нуля или более документов. Опять же, документ можно безопасно рассматривать как строку.
4. Документ состоит из одного или нескольких полей, которые, как вы, вероятно, догадываетесь, во многом похожи на столбцы или свойства класса.
5. Индексы в LiteDB функционируют в основном так же, как и их аналоги в СУБД.

## Характеристики

* Бессерверное хранилище документов NoSQL
* Простой API, очень похожий на официальный драйвер MongoDB
* 100% C #-код для .NET 3.5 /4.0 в одной DLL (менее 300 КБ) - Без зависимостей
* Поддержка переносимых платформ: Полная.NET и NET Standard 1.3+2.0 (для UWP 10, Xamarin iOS и Android)
* Потокобезопасный / многопроцессорный
* Восстановление при сбое записи (режим журнала)
* Поддержка классов POCO или BsonDocument
* Шифрование файла данных с использованием криптографии DES
* Хранилище файлов и потоковых данных (например, GridFS в MongoDB)
* Хранилище с одним файлом данных (например, SQLite)
* Индексированные поля документа для быстрого поиска (до 16 индексов в коллекции)
* Поддержка LINQ для запросов с поддержкой Include
* Командная строка командной оболочки (попробуйте эту онлайн-версию)
* С открытым исходным кодом и бесплатно для всех, включая коммерческое использование
* Установка из NuGet: Установочный пакет LiteDB
 
LiteDB во многом вдохновлен MongoDB. Я попытался создать базу данных, которая работает как MongoDB, но в очень малом масштабе, используя только самые важные функции для небольших приложений. Если вы знаете MongoDB, вы уже знаете LiteDB.

У LiteDB имеется официальный [GitHub](https://github.com/mbdavid/LiteDB), на котором лежат все исходники

## Где использовать?

* Небольшие веб-приложения, сайты, блоги или форумы
* Один файл данных для каждой учетной записи / хранилища данных пользователя
* Настольные / локальные небольшие приложения
* Формат файла приложения
* Несколько операций записи пользователей с параллелизмом

## История развития

Полная летопись развития LiteDB находится [здесь](https://github.com/mbdavid/LiteDB/releases?page=1). LiteDB была создана 25 января 2015 году. В настоящее время выпущена 5 версия данной СУБД. Ниже приведен небольшой список наиболее важных обновлений с изменениями.

Обновленная версия v5.0.16 - 19 марта 2023
* Использовать только мьютекс для общего механизма открытия и закрытия синхронизации и удалить блокировки с помощью@dev-joshiв № 2293
* Исправлена обработка Min(Func<T,TResult>) с помощью@gcrossland-cosworthв № 2287
* Измените тип возвращаемого значения ILiteRepository.Insert, чтобы он соответствовал ILiteDatabase.Insert,@InvisiblePhilв # 2260
* Исправлена опечатка@iArmanKarimiв № 2267
* Исправлена SqlLike@pjy612в № 2235

Обновление версии v5.0.0-alpha - 5 августа 2019
* Полностью новый движок - WAL (Write Ahead Log)
* Управление многоверсионным параллелизмом (снимки и контрольные точки)
* Полное сопровождение сделки
* Поддержка нескольких ридеров без блокировки
* Написать блокировку на уровне коллекции, а не на уровне базы данных
* Удвоено количество индексов на коллекцию, теперь до 32 индексов на коллекцию.
* Новый FileStorageс пользовательским Idтипом
* Новое BsonExpressions: преобразование, фильтрация, сопоставление, уменьшение, ..
* Новый Query Pipe внутри движка
* Простое обновление существующих баз данных LiteDB v4 (используйте upgrade=trueв строке подключения)
* Новый посетитель Linq (с поддержкой дополнительных выражений)
* Новый беглыйQuery
* И не один год напряженной работы!!
* Поддержка нового языка SQL — очень похоже на ANSI SQL.
* Выбрать, Вставить, Обновить, Удалить, Создать индекс, Удалить индекс, Удалить коллекцию, Объяснить
* Поддержка GroupBy, Наличие, Лимит, Смещение, OrderBy, Включает, ...
* Системные коллекции (получить информацию о базе данных)
* Поддержка системных функций (импорт/экспорт CSV/JSON)
* Новый графический интерфейс для Windows
* Несколько вкладок, несколько потоков, несколько транзакций
* Взаимодействуйте с вашей базой данных и коллекциями с помощью операторов SQL.

Обновление версии 4.0.0 - 18 октября 2017
* Только для NET4
* Новая поддержка выражений
* Исправлены проблемы параллелизма в версии v3
* Поддержка переносимости с использованием NETStandard 1.3 + 2.0
* Обновление v2.0.0 - 1 назад 2016
* Поддержка Portable - UWP, Xamarin - iOS и Android
* .NET 3.5
* Новый доступ к диску, позволяющий избежать функций блокировки: используйте только эксклюзивный режим чтения / записи
* Вернули некоторые функции версии v1: управление пользовательскими транзакциями, регистрацию AutoID и экземпляр global mapper

Обновление v.2.0.0-rc - 24 декабря 2015
* Файл данных шифрования
* Перенос файла данных с версии 0.9.0 / v1.0.x
* Дамп файла данных как вставка
* Улучшенная поддержка кэша / параллелизма
* Счастливого Рождества :)

Обновление v.2.0.0-бета - 27 ноября 2015
* Абстрактный уровень сохранения
* Fluent mapper API
* новый DBRef
* Поле виртуального индекса
* Новая система очистки кэша
* Поддержка начального размера базы данных и максимального размера базы данных
* Отложенная загрузка.
* Защита от потоков и процессов
* Сжатие файлов данных
* Информация журнала базы данных

Обновление v1.0.2 - 17 мая 2015
* Лучше, чтобы BsonMapper сериализовал / десериализовал интерфейсы и базовые классы, используя поле _type в документе (как используется в MongoDB)
* BsonMapper для сбора значений имен
* Добавлена поддержка логических операций Linq, таких как x => x.isActive
* Исправлена ошибка в операциях обновления / удаления индекса строки
* Удалены операции поиска документов при полном сканировании - теперь работает только с индексом
* Автоматическое создание индекса, если он не существует

Обновление v1.0 - 28 марта 2015
* Новый BsonSerializer удаляет fastBinaryJson и реализует реальную спецификацию BSON
* Новый BsonMapper для получения более настраиваемого POCO из / в BsonDocument
* Новая реализация JsonReader: без регулярных выражений и в 4 раза быстрее
* Новый идентификатор объекта, который будет использоваться в документах Id
* Параметры создания индекса - удаление пробелов, удаление акцентов, игнорирование регистра
* Атрибут [BsonIndex] для обозначения вашего свойства объекта для автоматического создания индекса при запросе
* Идентификатор автоматической генерации для свойства entity Id
* Find() может быть выполнен без индекса (выполнит полное сканирование документа)
* FindAll() поддерживает результаты по возрастанию / убыванию
* Минимальное () / Максимальное() значение из индекса
* DBRef<> - простой класс для справочного документа
* Улучшен сбор данных и индекс удаления
* Удалена коллекция _master - не прочитана 1 страница

Обновление версии 0.9 - 07 февраля 2015
* Добавили банковскую метку MongoDB
* Добавилен краткий обзор оболочки

Начальная версия - 25 января 2015

## Инструменты для взаимодействия и языки программирования

LiteDB — это бессерверная база данных, поставляемая в виде одной небольшой библиотеки DLL (< 450 КБ), полностью написанной на управляемом коде .NET C# (совместимом с .NET 4.5 и NETStandard 2.0).

* LiteDB поддерживает SQL-подобный язык для обработки данных и структур. Вы можете вставлять, обновлять, удалять или запрашивать базу данных, используя очень похожий реляционный язык SQL.
* Выражения LINQ (лямбда-функции) можно использовать для создания плавного запроса API в коде C#.
* Все команды SQL поддерживаются в новом инструменте администрирования LiteDB.Studio .
* Вы также можете получить подробный EXPLAIN PLAN от механизма запросов, чтобы проверить, будет ли ваш запрос выполняться с максимальной производительностью.
* LiteDB полностью написан на управляемом коде C#.
* Поддержка .NET Framework 4.5 и .NET Standard 1.3 и 2.0, .NET Core 2.0+, UWP, Linux, мобильного Xamarin (iOS и Android), Unity... на каждой платформе .NET
* LiteDB является бесплатным и открытым исходным кодом?

Информация взята с официального сайта.

![Текст с описанием картинки](/images/HW4-2.png)

## Database engine

Еще одно преимущество использования LiteDB заключается в том, что существует также «LiteDB Studio» , которую вы можете установить (фактически собрать из исходников) отдельно. Он позволяет подключаться к локальной базе данных и управлять ею с помощью приятного пользовательского интерфейса. Исходники можно посмотреть [здесь](https://github.com/mbdavid/LiteDB.Studio).

![Текст с описанием картинки](/images/HW4-3.jpg)

## Установка, документация и обучение

Скачать LiteDB можно по [ссылке](https://www.nuget.org/packages/LiteDB/). Более подробную информацию о установке можно найти [здесь](https://www.litedb.org/docs/getting-started/) и [здесь](https://litedb.readthedocs.io/en/latest/getting-started/getting-started.html). 

Документацию можно почитать как на официальном [сайте](https://www.litedb.org/docs/getting-started/), так и [здесь](https://litedb.readthedocs.io/en/latest/getting-started/getting-started.html). Также множество материалов имеется на [GitHub](https://github.com/mbdavid/LiteDB).

Полезное для обучения будет вот это [видео](https://www.youtube.com/watch?v=d2N4Ia8Wwd0), в котором показано, как работать с этой СУБД, а также есть [видео](https://www.youtube.com/watch?v=a3m4B5m6IqQ), где показано, как добавить LiteDB в Visual Studio. Следующие сайты могут быть полезны для начала работы с LiteDB: [1](https://dottutorials.net/nosql-db-dotnet-core-example-csharp-litedb-tutorial/#view-data-in-database), [2](https://www.c-sharpcorner.com/UploadFile/ranjancse/getting-started-with-litedb/), [3](https://dev.listera.top/docs/litedb/LiteDB-v1/), [4](https://metanit.com/sharp/articles/ado.net/1.php), [5](https://litedb.readthedocs.io/_/downloads/en/latest/pdf/). 

## Демобаза

В шаблоне на этом [сайте](https://zennolab.com/discussion/threads/proekt-dlja-raboty-s-litedb-udobnaja-nosql-baza-dlja-parsinga.83159/) примеры сниппетов для сохранения информации в базу. Используется версия 4.1.4, т.к. под эту линейку написан [explorer](https://github.com/julianpaulozzi/LiteDbExplorer) с хорошим UI и функционалом.

Порядок действий:
Добавить в папку ExternalAssemblies файлы: LiteDB.dll и LiteDB.xml
Прописать в директивы using:

```
using LiteDB;
```
Добавить LiteDB.dll из папки ExternalAssemblies в "Ссылки из GAC".

Краткий экскурс в JSON формат.
Все что вам нужно знать о JSON - это разница между фигурными {} и квадратными [] скобками. :-)

Фигурные скобки {} - это документ или объект, которому должно быть присвоено имя. Документ может включать документы, массивы и т.д.
```
{
    "name_1": "value_1",
    "name_2": "value_2"
}
```
Квадратные скобки [] - это массив объектов (array).
```
[
    "value_1",
    "value_2"
]
```
Это позволяет создавать структуры любой сложности и вложенности, а затем просто отправлять их в базу. Таким образом, нет необходимости заранее планировать структуру базы, нет необходимости подключаться к базе или держать локальный сервер. Информация хранится в одном файле.

В базе используется BSON, который расширяет поддержку форматов для JSON, поддерживаются ObjectID, Date, и т.д.

Для экспорта и работы с информацией используем LiteDbExplorer, позволяет работать с несколькими базами сразу, экспортировать в excel, csv и json.

## Демонстрация создания данных, запросов и индексации

### ***Наследование***

Специфика моей программы такова. Я хочу сохранять в базу простые объекты типа:

```
internal class Item
{
  public string Title { get; set; }

 public string Description { get; set; }

 public List<Field> Fields { get; set; } = new List<Field>();
}
```
Но вот класс `Field` у меня абстрактный, имеющий массу наследников:

```
internal abstract class Field
{
}

internal sealed class TextField : Field
{
 public string Text { get; set; }
}

internal sealed class PasswordField : Field
{
 public string Password { get; set; }
}

internal sealed class DescriptionField : Field
{
 public string Description { get; set; }
}
```

При работе с SQL базами данных мне приходилось настраивать сохранение различных наследников класса `Field`. Я полагал, что в LiteDB мне придётся писать собственный механизм BSON-сериализации, благо такая возможность предоставляется. Но LiteDB меня приятно удивил. Никаких усилий с моей стороны не потребовалось. Сохранение и восстановление различных типов происходит совершенно без моего участия. Вы создаёте нужные объекты:

```
var items = new Item[]
{
 new Item
 {
 Title = "item1",
 Description = "description1",
 Fields =
 {
 new TextField
 {
 Text = "text1"
 },
 new PasswordField
 {
 Password = "123"
 }
 }
 },
 new Item
 {
 Title = "item2",
 Description = "description2",
 Fields =
 {
 new TextField
 {
 Text = "text2"
 },
 new DescriptionField
 {
 Description = "description2"
 }
 }
 }
};
```
и вставляете их в базу данных:

```
using (var db = new LiteDatabase(connectionString))
{
 var collection = db.GetCollection<Item>();

 collection.InsertBulk(items);
}
```
Вот и всё. LiteDB поставляется с удобной программой LiteDB.Studio, которая позволяет вам исследовать содержимое вашей базы данных. Давайте посмотрим, как хранятся наши объекты:

```
{
 "_id": {"$oid": "62bf12ce12a00b0f966e9afa"},
 "Title": "item1",
 "Description": "description1",
 "Fields":
 [
 {
 "_type": "LiteDBSearching.TextField, LiteDBSearching",
 "Text": "text1"
 },
 {
 "_type": "LiteDBSearching.PasswordField, LiteDBSearching",
 "Password": "123"
 }
 ]
}
```
Оказывается, что для каждого объекта в поле `_type` сохраняется его тип, что и позволяет правильно восстановить объект при чтении из базы.

Что ж, с сохранением разобрались. Давайте перейдём к чтению.

### ***Поиск текста***

Как я уже сказал, мне необходимо искать объекты Item в свойствах `Title` и `Description` которых, а так же в свойствах их полей (свойство `Fields`) содержится определённый текст.

С поиском внутри свойств `Title` и `Description` всё ясно. Документация содержит понятные примеры:

```
var items = collection.Query()
 .Where(i => i.Title.Contains("1") || i.Description.Contains("1"))
 .ToArray();
 ```
 
Но с поиском в полях есть проблема. Дело в том, что абстрактный класс Field не определяет никаких свойств. Поэтому я не могу на них сослаться здесь. К счастью LiteDB позволяет использовать строковую запись запросов:

```
var items = collection.Query()
 .Where("$.Title LIKE '%1%' OR $.Description LIKE '%1%'")
 .ToArray();
 ```
 Но как с её помощью искать внутри полей? Документация даёт подсказку, что выражение должно выглядеть примерно так:
 
 ```
 $.Title LIKE '%1%' OR $.Description LIKE '%1%' OR ANY($.Fields[@.Text LIKE '%1%']) 
OR ANY($.Fields[@.Description LIKE '%1%']) OR ANY($.Fields[@.Password LIKE '%1%'])
```

Здесь меня смущали две вещи. Во-первых, для каждого нового типа поля мне могло потребоваться дописывать это выражение, если оно использовало новое имя текстового свойства, в котором мне нужно было осуществлять поиск. Можно ли что-то сделать по этому поводу? Можно.

LiteDB поддерживает атрибут `BsonField`, который позволяет задавать имя поля базы данных, в котором будет храниться данное свойство. Можно использовать его так:

```
internal sealed class TextField : Field
{
 [BsonField("TextField")]
 public string Text { get; set; }
}

internal sealed class PasswordField : Field
{
 [BsonField("TextField")]
 public string Password { get; set; }
}

internal sealed class DescriptionField : Field
{
 [BsonField("TextField")]
 public string Description { get; set; }
}
```

Теперь можно использовать одно поисковое выражение для любых объектов `Field`:

```
$.Title LIKE '%1%' OR $.Description LIKE '%1%' OR $.Fields[*].TextField ANY LIKE '%1%'
```

Добавляя нового наследника класса Field, я могу просто пометить его свойство атрибутом 'BsonField("TextField")'. Тогда мне не придётся вносить никаких изменений в поисковое выражение.

К сожалению этот способ не совсем решает все наши проблемы. Дело в том, что у наследника 'Field' может быть произвольное число свойств, в которых нужно осуществлять поиск. Поэтому может оказаться, что их нельзя привести к уже имеющимся в базе полям.

У неё есть ещё одна проблема. Мне несколько раз пришлось писать искомую строку `'%1%'`. Да и SQL Injection ещё никто не отменял (хотя не уверен, применимо ли здесь использовать слово SQL). Короче говоря, я веду к тому, что неплохо было бы использовать параметры запроса. И действительно, API позволяет это делать:

Но как конкретно мне сослаться на параметр в тексте запроса? К сожалению, документация опять подвела меня. Пришлось лезть в код тестов для LiteDB и искать там, как следует использовать параметры:

```
var items = collection.Query()
 .Where("$.Title LIKE @0 OR $.Description LIKE @0 OR ($.Fields[*].Text ANY LIKE @0) 
OR ($.Fields[*].Description ANY LIKE @0) OR ($.Fields[*].Password ANY LIKE @0)", "%1%")
 .ToArray();
 ```
 
 ### ***Индексация***
 
LiteDB повышает производительность поиска, используя индексы для полей или выражений документа. В каждом индексе хранится значение определенного выражения, упорядоченное по значению (и типу). Без индекса LiteDB должен выполнить запрос, используя полное сканирование документа. Полное сканирование документов неэффективно, поскольку LiteDB должна десериализовать каждый документ в коллекции.

Индексы в LiteDB реализованы с помощью списков пропуска . Списки пропуска представляют собой отсортированные с двойной связью списки, содержащие до 32 уровней. Списки пропуска очень просты в реализации (всего 15 строк кода) и статистически сбалансированы.

Операции вставки и поиска имеют среднюю сложность O (log n). Это означает, что в коллекции с 1 миллионом документов операция поиска по индексированному выражению займет около 13 шагов, чтобы найти нужный документ. Если вы хотите узнать больше о списках пропуска, посмотрите это [замечательное видео](https://www.youtube.com/watch?v=kBwUoWpeH_Q). 

Более подробную информацию про индексы можно найти в [документации](https://www.litedb.org/docs/indexes/).

Конечно, моё приложение будет хранить не такой большой объём данных, чтобы это было критически важно. Но всё же было бы хорошо, чтобы мои запросы использовали индексы и выполнялись быстро.

Во-первых, как нам узнать, использует ли данный запрос индекс или нет. Для этого в LiteDB есть команда `EXPLAIN`. В LiteDB.Studio я выполню свой запрос так:

```
EXPLAIN
SELECT $ FROM Item
WHERE $.Title LIKE '%1%'
    OR $.Description LIKE '%1%'
    OR ($.Fields[*].Text ANY LIKE '%1%')
 OR ($.Fields[*].Description ANY LIKE '%1%')
  OR ($.Fields[*].Password ANY LIKE '%1%')
```

Результат выполнения этой команды содержит следующую информацию об используемом индексе:
```
"index":
 {
 "name": "_id",
 "expr": "$._id",
 "order": 1,
 "mode": "FULL INDEX SCAN(_id)",
 "cost": 100
 },
 ```
 Как видите, сейчас применяется полный просмотр всех данных. Хотелось бы добиться лучшего результата.

Документация прямо говорит, что возможно создать индекс на основе свойств типа массив. При этом можно будет осуществлять поиск любого входящего в такие массивы значения. Например, вот так можно создать индекс для поиска информации в свойствах `Text` моих поле

```
collection.EnsureIndex("TextIndex", "$.Fields[*].Text");
```

Теперь этот индекс можно использовать в поиске:

```
var items = collection.Query()
 .Where("$.Fields[*].Text ANY LIKE @0", "%1%")
 .ToArray();
```

Команда `EXPLAIN` в LiteDB.Studio показывает, что этот запрос действительно использует созданный нами индекс:

```
"index":
 {
 "name": "TextIndex",
 "expr": "MAP($.Fields[*]=>@.Text)",
 "order": 1,
 "mode": "FULL INDEX SCAN(TextIndex LIKE \"%1%\")",
 "cost": 100
 },
 ```
 
Но как нам объединить в один индекс все наши свойства? На помощь приходит команда CONCAT. Она объединяет в один массив несколько свойств. Вот как будет выглядеть создание полного индекса:

```
collection.EnsureIndex("ItemsIndex", @"CONCAT($.Title,
 CONCAT($.Description,
 CONCAT($.Fields[*].Text,
 CONCAT($.Fields[*].Password,
 $.Fields[*].Description
 )
 )
 )
 )");
```
Чтобы искать по нему, нам придётся переписать наше поисковое выражение:

```
var items = collection.Query()
    .Where(
        @"CONCAT($.Title,
            CONCAT($.Description,
                CONCAT($.Fields[*].Text,
                    CONCAT($.Fields[*].Password,
                            $.Fields[*].Description
                    )
                )
            )
        ) ANY LIKE @0",
        "%1%")
    .ToArray();
```
Теперь наш поиск действительно использует индекс:

```
"index":
  {
    "name": "ItemsIndex",
    "expr": "CONCAT($.Title,CONCAT($.Description,CONCAT(MAP($.Fields[*]=>@.Text),CONCAT(MAP($.Fields[*]=>@.Password),MAP($.Fields[*]=>@.Description)))))",
    "order": 1,
    "mode": "FULL INDEX SCAN(ItemsIndex LIKE \"%3%\")",
    "cost": 100
  },
 ```
 
К сожалению, оператор `LIKE` всё равно приводит к `FULL INDEX SCAN`. Остаётся надеяться, что индекс всё же даёт некоторый выигрыш. Хотя, зачем нам надеяться. Мы же можем всё измерить. У нас же есть BenchmarkDotNet.

Я написал вот такой класс для проведения тестов быстродействия:

```
[SimpleJob(RuntimeMoniker.Net60)]
public class LiteDBSearchComparison
{
    private LiteDatabase _database;
    private ILiteCollection<Item> _collection;

    [GlobalSetup]
    public void Setup()
    {
        if (File.Exists("compare.dat"))
            File.Delete("compare.dat");

        _database = new LiteDatabase("Filename=compare.dat");

        _collection = _database.GetCollection<Item>();

        _collection.EnsureIndex("ItemIndex", @"CONCAT($.Title,
            CONCAT($.Description,
                CONCAT($.Fields[*].Text,
                    CONCAT($.Fields[*].Password,
                            $.Fields[*].Description
                    )
                )
            )
        )");

        for (int i = 0; i < 100; i++)
        {
            var item = new Item
            {
                Title = "t",
                Description = "d",
                Fields =
                {
                    new TextField { Text = "te" },
                    new PasswordField { Password = "p" },
                    new DescriptionField { Description = "de" }
                }
            };

            _collection.Insert(item);
        }
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        _database.Dispose();
    }

    [Benchmark(Baseline = true)]
    public void WithoutIndex()
    {
        _ = _collection.Query()
            .Where("$.Title LIKE @0 OR $.Description LIKE @0 OR ($.Fields[*].Text ANY LIKE @0) OR ($.Fields[*].Description ANY LIKE @0) OR ($.Fields[*].Password ANY LIKE @0)",
                "%1%")
            .ToArray();
    }

    [Benchmark]
    public void WithIndex()
    {
        _ = _collection.Query()
            .Where(@"CONCAT($.Title,
                        CONCAT($.Description,
                            CONCAT($.Fields[*].Text,
                                CONCAT($.Fields[*].Password,
                                        $.Fields[*].Description
                                )
                            )
                        )
                    ) ANY LIKE @0",
                "%1%")
            .ToArray();
    }
}
```
Результаты, которые я получил для него, следующие:

|Method|Mean|Error|StdDev|Ratio|
|:-:|:-:|:-:|:-:|:-:|
|C индексом|752.7 us|14.71 us|21.56 us|1.00|
|Без индекса|277.5 us|4.30 us|4.02 us|0.37|

## Процесс выполнения и план запросов

Запросы LiteDB должны использовать индексы для связанных полей запроса. Если индекса нет, индекс будет создан по умолчанию. В приведенном выше примере создается индекс поля и запроса. В LiteDB есть 2 способа запроса:

1. Используйте статический вспомогательный класс Query;

2. Использование метода Linq аналогично демонстрационному методу;

LiteDB использует Query для запроса следующих методов, подробно объясняя некоторые важные из них. Всем не должно быть сложно понять другие. Если есть какие-то неточности, пожалуйста, исправьте меня:

Query.All возвращает все данные, вы можете использовать указанное поле индекса для сортировки
Поиск Query.EQ возвращает данные, равные указанному значению поля
Query.LT/LTE находит данные с <или <= определенным значением
Query.GT/GTE, чтобы найти данные> или> = определенного значения
Query.Between находит данные в указанном диапазоне
Запрос. Как и в SQL в, найти данные, равные значению в списке.
Query.Not - в отличие от EQ, данные, не равные определенному значению
Query.StartsWith находит данные, начинающиеся со строки
Query.Contains находит данные, которые защищают определенную строку, этот запрос сканирует только индекс
Запрос и пересечение 2 запросов
Запрос или объединение двух результатов запроса

Посмотрите на реальный код:

```
var results = collection.Find(Query.EQ("Name", "John Doe"));
var results = collection.Find(Query.GTE("Age", 25));
var results = collection.Find(Query.And(
    Query.EQ("FirstName", "John"), Query.EQ("LastName", "Doe")
));
var results = collection.Find(Query.StartsWith("Name", "Jo"));
```
Как показано, синтаксисом является поле слева и значение справа. Обратите внимание, что LiteDB не поддерживает это выражение: CreationDate == DueDate.

Ниже представлены несколько основных методов запросов с использованием Linq:

`FindAll`: найти все записи результатов в таблице или коллекции
`FindOne`: вернуть первый результат или результат по умолчанию
`FindById`: вернуть один результат по индексу
`Find`: использовать выражение запроса или запрос выражения linq для возврата результатов

Взгляните на несколько примеров:

```
collection.EnsureIndex(x => x.Name);
var result = collection
    .Find(Query.EQ("Name", "John Doe")) 
    .Where(x => x.CreationDate >= x.DueDate.AddDays(-5)) 
    .OrderBy(x => x.Age)
    .Select(x => new 
    { 
        FullName = x.FirstName + " " + x.LastName, 
        DueDays = x.DueDate - x.CreationDate 
    });
 ```
Конечно, есть такие методы, как `Count (), Exists (), Min (), Max ()` и другие. . Легче понять. Посмотрите на пример запроса выражения linq:

```
var collection = db.GetCollection<Customer>("customer");
var results = collection.Find(x => x.Name == "John Doe");
var results = collection.Find(x => x.Age > 30);
var results = collection.Find(x => x.Name.StartsWith("John") && x.Age > 30);
```

Больше примеров и подробное описание можно посмотреть на следующей официальной [странице](https://github.com/mbdavid/LiteDB/wiki/Queries).

## Файловая система

Чтобы сохранить небольшой профиль памяти, LiteDB ограничивает размер документов до 1 МБ. Для большинства документов этого достаточно. Однако 1 МБ слишком мало для полезного хранилища файлов. По этой причине LiteDB реализует `FileStorage` пользовательскую коллекцию для хранения файлов и потоков.

Коллекция `FileStorage` содержит простые методы, такие как:

* `Upload`: отправить файл или поток в базу данных. Может использоваться с файлом или `Stream`. Если файл уже существует, содержимое файла перезаписывается.
* `Download`: Получите ваш файл из базы данных и скопируйте в `Stream` параметр
* `Delete`: удалить ссылку на файл и все фрагменты данных
* `Find`: найти один или несколько файлов в `_files` коллекции. Возвращает `LiteFileInfo` класс, после которого можно загрузить данные.
* `SetMetadata`: обновить сохраненные метаданные файла. Этот метод не изменяет значение сохраненного файла. Он обновляет значение `_files.metadata`.
* `OpenRead`: найти файл по `_id` и возвращает `LiteFileStream` для чтения содержимого файла в виде потока

`FileStorage`не поддерживает транзакции, чтобы не помещать весь файл в память перед его сохранением на диске. Транзакции используются по частям. Каждый загруженный фрагмент фиксируется в одной транзакции. Более подробное использование в [документации](https://www.litedb.org/docs/filestorage/).

## Транзакции

В v4 транзакции удалены, чтобы избежать блокировки файла данных между командами. Было важно исправить некоторые проблемы параллелизма версии 3.

Но транзакции потрясающие, в некоторых приложениях они действительно важны. Поэтому разработчик работал над другим способом реализации «транзакционной» операции. Идея заключается в том, чтобы реализовать что-то вроде Entity Framework: работать с объектами в памяти и при вызове «SaveChanges» сохранять все изменения в одной операции с файлом данных (и, если возникает какая-либо ошибка, откатывать все).

Итак, вот предложение:

```
using(var db = new LiteDatabase("..."))
{
    var customers = db.GetCollection<Customer>("customers");
    var orders = db.GetCollection<Order>("orders");
    
    var cust1 = new Customer { Name = "John" };
    var order1 = new Order { Date = DateTime.Now, Customer = cust1 };
    
    customers.Add(cust1);
    orders.Add(order1);
    
    // no datafile operation until here
    // all entities are in memory (as a List<Entity> Changes)
    // so, "customers.FindById(1) == null"
    
    db.SaveChanges(); 
    // now, in a single datafile operation:
    // - "cust1" will be serialized, inserted and setted "CustomerId"
    // - "order1" will be serialized (and will get reference from cust1), inserted and setted "OrderId"
    
    // "Updating"
    
    var cust2 = customers.FindById(2);
    
    cust2.Name = "Newton";
    
    customers.Set(cust2);
    
    // to avoid track all return objects (from Find), you will need use "Set" to be updated later
    
    db.SaveChanges();
    
    // also, will be avaiable
    // customers.Save(entity) - works as Upsert()
    // customers.Remove(entity) - works as Delete()
    
}
```

* Эти 4 метода будут работать со списком изменений (`List<Entity>`), которые будут выполняться в порядке включения в этот список при `SaveChanges` вызове.
* Текущий 'Insert(), Update(), Delete()' метод будет работать как исключенный
* Пока 'SaveChanges()' все добавленные/обновленные/удаленные сущности не отразятся в 'Find' операциях

## Методы восстановления

Параметры восстановления используются для настройки перестроения.

![Текст с описанием картинки](/images/HW4-4.PNG)

Ребилды также полезны для дефрагментации файла данных, уменьшения его размера и ускорения доступа.

* 'rebuild;' перестраивает базу данных с параметрами сортировки по умолчанию и без пароля
* 'rebuild {"collation": "en-GB/IgnoreCase"};' перестраивает файл данных с 'en-GB' культурой и сравнением строк без учета регистра
* 'rebuild {"collation": "pt-BR/None", "password" : "1234"};' перестраивает файл данных с 'pt-BR' культурой, сравнением строк с учетом регистра и устанавливает пароль «1234».

Сопоставление — это специальная прагма (дополнительную информацию см. в разделе Прагмы ), которая позволяет пользователям указывать язык и параметры сравнения строк для файла данных.

'Collation' — это прагма, доступная только для чтения, и ее можно изменить только с помощью перестроения.

Сопоставление указывается в формате 'CultureName/CompareOption1[,CompareOptionN]'. Дополнительные сведения о параметрах сравнения см. в документации по .NET .

Файлы данных всегда создаются с 'CultureInfo.CurrentCulture' параметрами культуры и 'IgnoreCase' параметра сравнения. Сопоставление можно изменить, перестроив файл данных.

Внутри информация о культуре хранится в заголовке файла данных с использованием значения LCID. Культуры со значением LCID 4096 не поддерживаются. Когда обнаруживается неподдерживаемый язык и региональные параметры, по умолчанию для перестроения используется 'CultureInfo.InvariantCulture'.

Подробную информацию можно прочитать [здесь](https://www.litedb.org/docs/pragmas/) и [здесь](https://www.litedb.org/docs/collation/).

## Метод защиты - шифрование 

LiteDB использует `AES` (как определено в [RFC 2898](https://datatracker.ietf.org/doc/html/rfc2898) ) в качестве шифрования. Это реализуется классом `Rfc2898DeriveBytes`.

Объект `Aes`, используемый для криптографии, инициализируется с помощью `PaddingMode.None` и `CipherMode.ECB`.

Пароль для зашифрованного файла данных определяется в строке подключения (для получения дополнительной информации см. [строку подключения](https://www.litedb.org/docs/connection-string/)). Пароль можно изменить или удалить только путем перестроения файла данных (для получения дополнительной информации см. Параметры перестроения в [Pragmas](https://www.litedb.org/docs/pragmas/)).

## Шардинг

Шардинг - это техника горизонтального масштабирования баз данных, которая позволяет разбить данные на несколько фрагментов (шардов) и хранить их на разных серверах. Это увеличивает производительность и возможность обработки большого объема данных.

В LiteDB шардинг реализуется через использование нескольких файлов базы данных. Каждый файл содержит свой набор [коллекций](https://www.litedb.org/docs/collections/), которые могут хранить данные. При выполнении запросов LiteDB автоматически определяет, в каком файле находится необходимая коллекция, и выполняет запрос в соответствующем файле.

Важно отметить, что LiteDB не поддерживает автоматический балансировщик нагрузки между шардами, поэтому это должно быть реализовано вручную.

## Data Mining, Data Warehousing и OLAP

Термины Data Mining, Data Warehousing и OLAP относятся к области анализа данных и хранения данных. В случае LiteDB, который является легковесной встраиваемой базой данных, не все эти термины применимы.

Data Mining (добыча данных) - это процесс извлечения практически полезной информации из большого объема данных. LiteDB не предоставляет встроенных средств для анализа данных или добычи данных. Однако, если необходимо выполнить анализ данных, данные могут быть извлечены из LiteDB и переданы для обработки в другие инструменты для Data Mining.

Data Warehousing (хранилище данных) - это процесс сбора, хранения и управления данными из разных источников, чтобы обеспечить быстрый и удобный доступ к этим данным для аналитических целей. LiteDB может использоваться как одно из хранилищ данных в системе, однако, это не является единственным инструментом для хранения данных. 

OLAP (Online Analytical Processing) - это технология анализа данных, которая позволяет анализировать большие объемы данных в реальном времени. LiteDB не имеет встроенных средств для анализа данных OLAP. Однако, если необходимо выполнить OLAP-анализ, данные могут быть извлечены из LiteDB и переданы для обработки в другие инструменты для OLAP.

Таким образом, хотя LiteDB может использоваться для хранения данных, он не является полноценным инструментом для анализа данных и OLAP-анализа.

## Сообщество LiteDB

LiteDB — это растущее сообщество, которому нужна ваша помощь. Вы можете внести свой вклад с помощью LiteDB разными способами:

* Решите проблему с ошибкой [Github](https://github.com/mbdavid/LiteDB/issues)
* Общайтесь с разработчиками в [Gitter](https://app.gitter.im/#/room/#mbdavid_LiteDB:gitter.im)
* Задайте вопросы в [StackOverflow](https://stackoverflow.com/users/login?ssrc=anon_ask&returnurl=https%3a%2f%2fstackoverflow.com%2fquestions%2fask)
* Ответь на несколько вопросов о том, как вы используете LiteDB, в [форме](https://docs.google.com/forms/d/e/1FAIpQLSc4cNG7wyLKXXcOLIt7Ea4TlXCG6s-51_EfHPu2p5WZ2dIx7A/viewform) 
* Следите за новостями в [Twitter](https://twitter.com/mbdavid)

![Текст с описанием картинки](/images/HW4-5.PNG)

Официально на сайте команда состоит из 3 человек: основатель/разработчик - Маурисио Давид (слева), разработчик - Кассиано Сомбрио (в центре),разработчик - Леонардо Насименто (справа).

Известно, что все члены команды из Бразилии. Про личную жизнь разработчиков ничего неизвестно, но есть несколько сайтов с рабочей информацией. Вся информация про LiteDB завязана на аккуантах основателя Маурисио Давида. Информация про Маурисио: [1](https://github.com/mbdavid), [2](https://app.gitter.im/#/room/#mbdavid_LiteDB:gitter.im), [3](https://www.codeproject.com/script/Membership/View.aspx?mid=1384501). Информация про Кассиано: [1](https://githubrecord.com/kcsombrio). Информация про Леонардо: [1](https://github.com/lbnascimento), [2](https://giter.club/lbnascimento), [3](https://giters.com/lbnascimento), [4](https://githubrecord.com/lbnascimento).

